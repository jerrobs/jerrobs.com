<!DOCTYPE html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width" name=viewport><link href=/assets/icons/favicon.svg rel=icon type=image/svg+xml><link href=https://www.jerrobs.com/issues/pathices/pth-003/ rel=canonical><meta content="Astro v2.6.1" name=generator><title>Making it precise</title><meta content="Making it precise" name=title><meta content="Rounding errors due to storing values as floating point values can easily get out of hand, particular care is required if you can only safely assume 16 bit precision. While the propagation of rounding errors can be a real problem with all numerical approaches, special care must be taken to make it work with 16-bit precision.
" name=description><meta content="Dirk Rathje" name=author><script src=/toggle-theme.js defer=defer></script><link href=/manifest.webmanifest rel=manifest><link href=/assets/about-d0c889e7.css rel=stylesheet /><script src=/_astro/hoisted.88db4f2a.js type=module></script></head><body><div class=layout><div class=layout__header><header class=astro-3EF6KSR2><a class="astro-3EF6KSR2 skip-to-content" href=#main-content>Skip to content</a><div class="astro-3EF6KSR2 nav-container"><a class="astro-3EF6KSR2 logo" href=/ ><object alt="[logo] J. Err. Obs" class="astro-3EF6KSR2 jerrobs" data=/assets/jerrobs.svg height=28 type=image/svg+xml width=138></object></a><nav class=astro-3EF6KSR2 id=nav-menu><ul class="astro-3EF6KSR2 body-md" id=menu-items><li class=astro-3EF6KSR2><a class=astro-3EF6KSR2 href=/issues>Issues</a></li><li class=astro-3EF6KSR2><a class=astro-3EF6KSR2 href=/references>References</a></li><li class=astro-3EF6KSR2><a class=astro-3EF6KSR2 href=/about>About</a></li><li class=astro-3EF6KSR2><button aria-label=auto aria-live=polite class="astro-3EF6KSR2 focus-outline" id=theme-btn title="Toggles light & dark"><svg class=astro-3EF6KSR2 id=moon-svg xmlns=http://www.w3.org/2000/svg><path class=astro-3EF6KSR2 d="M21.7519 15.0019C20.597 15.4839 19.3296 15.75 18 15.75C12.6152 15.75 8.25 11.3848 8.25 5.99999C8.25 4.67039 8.51614 3.40296 8.99806 2.24805C5.47566 3.71785 3 7.19481 3 11.25C3 16.6348 7.36522 21 12.75 21C16.8052 21 20.2821 18.5243 21.7519 15.0019Z" stroke=#0F172A stroke-linecap=round stroke-linejoin=round stroke-width=1.5 xmlns=http://www.w3.org/2000/svg></path></svg> <svg class=astro-3EF6KSR2 id=sun-svg xmlns=http://www.w3.org/2000/svg><path class=astro-3EF6KSR2 d="M12 3V5.25M18.364 5.63604L16.773 7.22703M21 12H18.75M18.364 18.364L16.773 16.773M12 18.75V21M7.22703 16.773L5.63604 18.364M5.25 12H3M7.22703 7.22703L5.63604 5.63604M15.75 12C15.75 14.0711 14.0711 15.75 12 15.75C9.92893 15.75 8.25 14.0711 8.25 12C8.25 9.92893 9.92893 8.25 12 8.25C14.0711 8.25 15.75 9.92893 15.75 12Z" stroke=#0F172A stroke-linecap=round stroke-linejoin=round stroke-width=1.5 xmlns=http://www.w3.org/2000/svg></path></svg></button></li></ul></nav></div></header><nav class="astro-ILHXCYM7 breadcrumb" aria-label=breadcrumb><p class=astro-ILHXCYM7></p><ul class=astro-ILHXCYM7><li class="astro-ILHXCYM7 body-sm"><a class=astro-ILHXCYM7 href=/ >Home</a></li><li class="astro-ILHXCYM7 body-sm"><a class=astro-ILHXCYM7 href=/issues>issues</a></li><li class="astro-ILHXCYM7 body-sm"><a class=astro-ILHXCYM7 href=/issues/pathices>pathices</a></li><li class="astro-ILHXCYM7 body-sm"><a class=astro-ILHXCYM7 href=/issues/pathices/pth-003>pth-003</a></li></ul></nav></div><div class=layout__main><article class=article role=article><header class=article-header><h1 class="body-xl italic uppercase article-title bold">Making it precise</h1><p class="body-xl italic uppercase article-subtitle">by outsmarting floating&nbsp; point limitations</p><p class="body-md article-abstract bold mb-1">Rounding errors due to storing values as floating point values can easily get out of hand, particular care is required if you can only safely assume 16 bit precision. While the propagation of rounding errors can be a real problem with all numerical approaches, special care must be taken to make it work with 16-bit precision.</p></header><div class=article-body><p class=md>If it is true that the devil is in the details, then getting numerical simulations to work in web browsers on different devices is a statistical endeavor.</p><p class=md>The root of the evil are floating point numbers, which are not a bad thing per se, but a neat trick to store numbers of very different magnitude and reasonably acceptable precision in a memory-efficient way. They solve the problem of representing an infinite number of numbers with limited memory - be it 16 bit, 32 bit or 64 (in the case of WebGL even 24 bit on some devices).</p><div class=level1><p class=md>To store any number <code>x</code> in computer memory you need a binary representation of that number:</p><pre class="astro-code one-dark-pro" is:raw="" style=background-color:#282c34;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word tabindex=0><code><span class=line><span style=color:#abb2bf>x </span><span style=color:#c678dd>=</span><span style=color:#abb2bf> aₙ aₙ₋₁ … a₀.a₋₁ a₋₂…a₋ₘ</span></span>
<span class=line></span></code></pre><p class=md>where <code>aₙ aₙ₋₁ … a₀</code> represents the integer part and <code>a₋₁ a₋₂…a₋ₘ</code> the fractional part of <code>x</code>.</p><p class=md>We have to decide how many bits to use for its integer part, and how many for its fractional part.</p></div><p class=md>When using WebGL for numerical simulations, floating point numbers cause trouble in two places:</p><ol class=md><li class=md>While smartphones GPUs know to read floating points and to do arithmetics with them, they cannot write them back to memory. Therefore, we need to convert them from and to some integer based representation.</li><li class=md>While desktop GPUs can write floating points back to memory, the precision of</li></ol><section class=md><h2 class=md id=ieee-754>IEEE 754</h2><p class=md>For nearly all hardware and programming languages, floating-point numbers are stored in the same binary format defined on the 70 pages of the <em>IEEE Standard for Floating-Point Arithmetic (IEEE 754)</em> (<bib-ref cite-key=ieee__2019__754>,<bib-ref cite-key=ieee__2019__754>)</bib-ref></bib-ref></p><p class=md>The usual formats are 32 or 64 bits in total length:</p><p class=md>The first version of the standard was published in 1985 by the Institute of Electrical and Electronics Engineers (IEEE). The first revision was published in 2008, the third and current (as of 2020) revision was published in 2019.</p><p class=md>The IEEE754 standards, representing double precision numbers with 64 bits (a.k.a double, or float64) and single precision numbers with 32 bits (a.k.a float32).</p><p class=md>defines how almost all modern programming languages, GPUs and CPUs handle floating-point numbers.</p></section><section class=md><h2 class=md id=rounding-errors-tragedies>Rounding errors tragedies</h2><ul class=md><li class=md><p class=md>On February 25, 1991, a poor implementation fo floating point artithmetics contributed to the death of 28 soldiers from the U.S. Army’s 14th Quartermaster Detachment in Dhahran, Saudi Arabia. Although the soldiers’ location was protected from Iraqi Scud missiles by a Patriot defence system, floating points rounding errors caused the system’s internal clock to be inaccurate by .34 seconds after being in operation for 100 hours. For a Scud missile travelling at 1600 m/s, a third of a second corresponds to half a kilometre (<bib-ref cite-key=benchoff__2015__improvement>).</bib-ref></p></li><li class=md><p class=md><strong>NOT FLOATIONG POINT, BUT OVERFLOW</strong>. On 4 June 1996 — after ten years of development and cost of 7 billion dollars — the maiden flight of the Ariane 5 launcher ended in a failure. At 39 seconds after liftoff it exploded because a conversion from a 64-bit floating point to a 16-bit integer made the steering computer think the rocket was way off course and made it initiate the self-destruct mechanism built into the rocket — destroying the rocket and cargo valued at half a billion dollars (<bib-ref cite-key=stadther__1998__high>,<bib-ref cite-key=lions__1999__ariane>,<bib-ref cite-key=cnn__1996__unmanned>).</bib-ref></bib-ref></bib-ref></p></li><li class=md><p class=md>Belotti argues that one reason of the 50 years old programming language COBOL being still used for the majority of financial transacions worldwide is that it has fixed point numbers being build-in (<bib-ref cite-key=bellotti__2018__cobol>)</bib-ref></p></li></ul></section></div></article></div><div class=layout__footer><footer class="astro-SZ7XMLTE footer-wrapper"><p class="astro-SZ7XMLTE copyright-wrapper"><span class=astro-SZ7XMLTE>&#169; 2023</span> <span class="astro-SZ7XMLTE separator">&nbsp;|&nbsp;</span> <span class=astro-SZ7XMLTE>All rights reserved.</span></p></footer></div></div></body></html>